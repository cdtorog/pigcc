"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OlStyleParser = void 0;
var geostyler_style_1 = require("geostyler-style");
var ImageState_1 = __importDefault(require("ol/ImageState"));
var MapUtil_1 = __importDefault(require("@terrestris/ol-util/dist/MapUtil/MapUtil"));
var Point_1 = __importDefault(require("ol/geom/Point"));
var Style_1 = __importDefault(require("ol/style/Style"));
var Image_1 = __importDefault(require("ol/style/Image"));
var Stroke_1 = __importDefault(require("ol/style/Stroke"));
var Text_1 = __importDefault(require("ol/style/Text"));
var Circle_1 = __importDefault(require("ol/style/Circle"));
var Fill_1 = __importDefault(require("ol/style/Fill"));
var Icon_1 = __importDefault(require("ol/style/Icon"));
var RegularShape_1 = __importDefault(require("ol/style/RegularShape"));
var OlStyleUtil_1 = __importDefault(require("./Util/OlStyleUtil"));
var render_1 = require("ol/render");
var _get = require('lodash/get');
/**
 * This parser can be used with the GeoStyler.
 * It implements the GeoStyler-Style Parser interface to work with OpenLayers styles.
 *
 * @class OlStyleParser
 * @implements StyleParser
 */
var OlStyleParser = /** @class */ (function () {
    function OlStyleParser(ol) {
        this.unsupportedProperties = {
            Symbolizer: {
                MarkSymbolizer: {
                    avoidEdges: 'none',
                    blur: 'none',
                    fillOpacity: 'none',
                    offsetAnchor: 'none',
                    pitchAlignment: 'none',
                    pitchScale: 'none',
                    visibility: 'none'
                },
                FillSymbolizer: {
                    antialias: 'none',
                    fillOpacity: {
                        support: 'none',
                        info: 'Use opacity instead.'
                    },
                    graphicFill: 'none',
                    visibility: 'none'
                },
                IconSymbolizer: {
                    allowOverlap: 'none',
                    anchor: 'none',
                    avoidEdges: 'none',
                    color: 'none',
                    haloBlur: 'none',
                    haloColor: 'none',
                    haloWidth: 'none',
                    keepUpright: 'none',
                    offsetAnchor: 'none',
                    optional: 'none',
                    padding: 'none',
                    pitchAlignment: 'none',
                    rotationAlignment: 'none',
                    textFit: 'none',
                    textFitPadding: 'none',
                    visibility: 'none'
                },
                LineSymbolizer: {
                    blur: 'none',
                    gapWidth: 'none',
                    gradient: 'none',
                    miterLimit: 'none',
                    roundLimit: 'none',
                    spacing: 'none',
                    visibility: 'none',
                    graphicFill: 'none',
                    graphicStroke: 'none',
                    perpendicularOffset: 'none'
                },
                RasterSymbolizer: 'none'
            }
        };
        this.title = 'OpenLayers Style Parser';
        this.olIconStyleCache = {};
        this.OlStyleConstructor = Style_1.default;
        this.OlStyleImageConstructor = Image_1.default;
        this.OlStyleFillConstructor = Fill_1.default;
        this.OlStyleStrokeConstructor = Stroke_1.default;
        this.OlStyleTextConstructor = Text_1.default;
        this.OlStyleCircleConstructor = Circle_1.default;
        this.OlStyleIconConstructor = Icon_1.default;
        this.OlStyleRegularshapeConstructor = RegularShape_1.default;
        this.isOlParserStyleFct = function (x) {
            return typeof x === 'function';
        };
        if (ol) {
            this.OlStyleConstructor = ol.style.Style;
            this.OlStyleImageConstructor = ol.style.Image;
            this.OlStyleFillConstructor = ol.style.Fill;
            this.OlStyleStrokeConstructor = ol.style.Stroke;
            this.OlStyleTextConstructor = ol.style.Text;
            this.OlStyleCircleConstructor = ol.style.Circle;
            this.OlStyleIconConstructor = ol.style.Icon;
            this.OlStyleRegularshapeConstructor = ol.style.RegularShape;
        }
    }
    /**
     * Get the GeoStyler-Style PointSymbolizer from an OpenLayers Style object.
     *
     * @param {object} olStyle The OpenLayers Style object
     * @return {PointSymbolizer} The GeoStyler-Style PointSymbolizer
     */
    OlStyleParser.prototype.getPointSymbolizerFromOlStyle = function (olStyle) {
        var pointSymbolizer;
        if (olStyle.getImage() instanceof this.OlStyleCircleConstructor) {
            // circle
            var olCircleStyle = olStyle.getImage();
            var olFillStyle = olCircleStyle.getFill();
            var olStrokeStyle = olCircleStyle.getStroke();
            var offset = olCircleStyle.getDisplacement();
            var circleSymbolizer = {
                kind: 'Mark',
                wellKnownName: 'circle',
                color: olFillStyle ? OlStyleUtil_1.default.getHexColor(olFillStyle.getColor()) : undefined,
                opacity: olFillStyle ? OlStyleUtil_1.default.getOpacity(olFillStyle.getColor()) : undefined,
                radius: (olCircleStyle.getRadius() !== 0) ? olCircleStyle.getRadius() : 5,
                strokeColor: olStrokeStyle ? olStrokeStyle.getColor() : undefined,
                strokeOpacity: olStrokeStyle ? OlStyleUtil_1.default.getOpacity(olStrokeStyle.getColor()) : undefined,
                strokeWidth: olStrokeStyle ? olStrokeStyle.getWidth() : undefined,
                offset: offset[0] || offset[1] ? offset : undefined
            };
            pointSymbolizer = circleSymbolizer;
        }
        else if (olStyle.getImage() instanceof this.OlStyleRegularshapeConstructor) {
            // square, triangle, star, cross or x
            var olRegularStyle = olStyle.getImage();
            var olFillStyle = olRegularStyle.getFill();
            var olStrokeStyle = olRegularStyle.getStroke();
            var radius = olRegularStyle.getRadius();
            var radius2 = olRegularStyle.getRadius2();
            var points = olRegularStyle.getPoints();
            var angle = olRegularStyle.getAngle();
            var offset = olRegularStyle.getDisplacement();
            var markSymbolizer = {
                kind: 'Mark',
                color: olFillStyle ? OlStyleUtil_1.default.getHexColor(olFillStyle.getColor()) : undefined,
                opacity: olFillStyle ? OlStyleUtil_1.default.getOpacity(olFillStyle.getColor()) : undefined,
                strokeColor: olStrokeStyle ? olStrokeStyle.getColor() : undefined,
                strokeOpacity: olStrokeStyle ? OlStyleUtil_1.default.getOpacity(olStrokeStyle.getColor()) : undefined,
                strokeWidth: olStrokeStyle ? olStrokeStyle.getWidth() : undefined,
                radius: (radius !== 0) ? radius : 5,
                // Rotation in openlayers is radians while we use degree
                rotate: olRegularStyle.getRotation() / Math.PI * 180,
                offset: offset[0] || offset[1] ? offset : undefined
            };
            switch (points) {
                case 2:
                    switch (angle) {
                        case 0:
                            markSymbolizer.wellKnownName = 'shape://vertline';
                            break;
                        case Math.PI / 2:
                            markSymbolizer.wellKnownName = 'shape://horline';
                            break;
                        case Math.PI / 4:
                            markSymbolizer.wellKnownName = 'shape://slash';
                            break;
                        case 2 * Math.PI - (Math.PI / 4):
                            markSymbolizer.wellKnownName = 'shape://backslash';
                            break;
                        default:
                            break;
                    }
                    break;
                case 3:
                    switch (angle) {
                        case 0:
                            markSymbolizer.wellKnownName = 'triangle';
                            break;
                        case Math.PI / 2:
                            markSymbolizer.wellKnownName = 'shape://carrow';
                            break;
                        default:
                            break;
                    }
                    break;
                case 4:
                    if (Number.isFinite(radius2)) {
                        // cross or x
                        if (olRegularStyle.getAngle() === 0) {
                            // cross
                            markSymbolizer.wellKnownName = 'cross';
                        }
                        else {
                            // x
                            markSymbolizer.wellKnownName = 'x';
                        }
                    }
                    else {
                        // square
                        markSymbolizer.wellKnownName = 'square';
                    }
                    break;
                case 5:
                    // star
                    markSymbolizer.wellKnownName = 'star';
                    break;
                default:
                    throw new Error('Could not parse OlStyle. Only 2, 3, 4 or 5 point regular shapes are allowed');
            }
            pointSymbolizer = markSymbolizer;
        }
        else if (olStyle.getText() instanceof this.OlStyleTextConstructor) {
            var olTextStyle = olStyle.getText();
            var olFillStyle = olTextStyle.getFill();
            var olStrokeStyle = olTextStyle.getStroke();
            var rotation = olTextStyle.getRotation();
            var char = olTextStyle.getText() || 'a';
            var font = olTextStyle.getFont() || '10px sans-serif';
            var fontName = OlStyleUtil_1.default.getFontNameFromOlFont(font);
            var radius = OlStyleUtil_1.default.getSizeFromOlFont(font);
            var offset = [olTextStyle.getOffsetX(), olTextStyle.getOffsetY()];
            pointSymbolizer = {
                kind: 'Mark',
                wellKnownName: "ttf://" + fontName + "#0x" + char.charCodeAt(0).toString(16),
                color: olFillStyle ? OlStyleUtil_1.default.getHexColor(olFillStyle.getColor()) : undefined,
                opacity: olFillStyle ? OlStyleUtil_1.default.getOpacity(olFillStyle.getColor()) : undefined,
                strokeColor: olStrokeStyle ? olStrokeStyle.getColor() : undefined,
                strokeOpacity: olStrokeStyle ? OlStyleUtil_1.default.getOpacity(olStrokeStyle.getColor()) : undefined,
                strokeWidth: olStrokeStyle ? olStrokeStyle.getWidth() : undefined,
                radius: (radius !== 0) ? radius : 5,
                // Rotation in openlayers is radians while we use degree
                rotate: rotation ? rotation / Math.PI * 180 : 0,
                offset: offset[0] || offset[1] ? offset : undefined
            };
        }
        else {
            // icon
            var olIconStyle = olStyle.getImage();
            var offset = olIconStyle.getDisplacement();
            var iconSymbolizer = {
                kind: 'Icon',
                image: olIconStyle.getSrc() ? olIconStyle.getSrc() : undefined,
                opacity: olIconStyle.getOpacity(),
                size: (olIconStyle.getScale() !== 0) ? olIconStyle.getScale() : 5,
                // Rotation in openlayers is radians while we use degree
                rotate: olIconStyle.getRotation() / Math.PI * 180,
                offset: offset[0] || offset[1] ? offset : undefined
            };
            pointSymbolizer = iconSymbolizer;
        }
        return pointSymbolizer;
    };
    /**
     * Get the GeoStyler-Style LineSymbolizer from an OpenLayers Style object.
     *
     * @param {object} olStyle The OpenLayers Style object
     * @return {LineSymbolizer} The GeoStyler-Style LineSymbolizer
     */
    OlStyleParser.prototype.getLineSymbolizerFromOlStyle = function (olStyle) {
        var olStrokeStyle = olStyle.getStroke();
        // getLineDash returns null not undefined. So we have to double check
        var dashArray = olStrokeStyle ? olStrokeStyle.getLineDash() : undefined;
        return {
            kind: 'Line',
            color: olStrokeStyle ? OlStyleUtil_1.default.getHexColor(olStrokeStyle.getColor()) : undefined,
            opacity: olStrokeStyle ? OlStyleUtil_1.default.getOpacity(olStrokeStyle.getColor()) : undefined,
            width: olStrokeStyle ? olStrokeStyle.getWidth() : undefined,
            cap: olStrokeStyle ? olStrokeStyle.getLineCap() : 'butt',
            join: olStrokeStyle ? olStrokeStyle.getLineJoin() : 'miter',
            dasharray: dashArray ? dashArray : undefined,
            dashOffset: olStrokeStyle ? olStrokeStyle.getLineDashOffset() : undefined
        };
    };
    /**
     * Get the GeoStyler-Style FillSymbolizer from an OpenLayers Style object.
     *
     * PolygonSymbolizer Stroke is just partially supported.
     *
     * @param {OlStyle} olStyle The OpenLayers Style object
     * @return {FillSymbolizer} The GeoStyler-Style FillSymbolizer
     */
    OlStyleParser.prototype.getFillSymbolizerFromOlStyle = function (olStyle) {
        var olFillStyle = olStyle.getFill();
        var olStrokeStyle = olStyle.getStroke();
        // getLineDash returns null not undefined. So we have to double check
        var outlineDashArray = olStrokeStyle ? olStrokeStyle.getLineDash() : undefined;
        return {
            kind: 'Fill',
            color: olFillStyle ? OlStyleUtil_1.default.getHexColor(olFillStyle.getColor()) : undefined,
            opacity: olFillStyle ? OlStyleUtil_1.default.getOpacity(olFillStyle.getColor()) : undefined,
            outlineColor: olStrokeStyle ? OlStyleUtil_1.default.getHexColor(olStrokeStyle.getColor()) : undefined,
            outlineDasharray: outlineDashArray ? outlineDashArray : undefined,
            outlineOpacity: olStrokeStyle ? OlStyleUtil_1.default.getOpacity(olStrokeStyle.getColor()) : undefined,
            outlineWidth: olStrokeStyle ? olStrokeStyle.getWidth() : undefined
        };
    };
    /**
     * Get the GeoStyler-Style TextSymbolizer from an OpenLayers Style object.
     *
     *
     * @param olStyle The OpenLayers Style object
     * @return The GeoStyler-Style TextSymbolizer
     */
    OlStyleParser.prototype.getTextSymbolizerFromOlStyle = function (olStyle) {
        var olTextStyle = olStyle.getText();
        var olFillStyle = olTextStyle.getFill();
        var olStrokeStyle = olTextStyle.getStroke();
        var offsetX = olTextStyle.getOffsetX();
        var offsetY = olTextStyle.getOffsetY();
        var font = olTextStyle.getFont();
        var rotation = olTextStyle.getRotation();
        var allowOverlap = olTextStyle.getOverflow() ? olTextStyle.getOverflow() : undefined;
        var text = olTextStyle.getText();
        var fontStyleWeightSize;
        var fontSizePart;
        var fontSize = Infinity;
        var fontFamily = undefined;
        if (font) {
            var fontSplit = font.split('px');
            // font-size is always the first part of font-size/line-height
            fontStyleWeightSize = fontSplit[0].trim();
            fontSizePart = fontStyleWeightSize.split(' ');
            // The last element contains font size
            fontSize = parseInt(fontSizePart[fontSizePart.length - 1], 10);
            var fontFamilyPart = fontSplit.length === 2 ?
                fontSplit[1] : fontSplit[2];
            fontFamily = fontFamilyPart.split(',').map(function (fn) {
                return fn.startsWith(' ') ? fn.slice(1) : fn;
            });
        }
        return {
            kind: 'Text',
            label: text,
            allowOverlap: allowOverlap,
            color: olFillStyle ? OlStyleUtil_1.default.getHexColor(olFillStyle.getColor()) : undefined,
            size: isFinite(fontSize) ? fontSize : undefined,
            font: fontFamily,
            offset: (offsetX !== undefined) && (offsetY !== undefined) ? [offsetX, offsetY] : [0, 0],
            haloColor: olStrokeStyle && olStrokeStyle.getColor() ?
                OlStyleUtil_1.default.getHexColor(olStrokeStyle.getColor()) : undefined,
            haloWidth: olStrokeStyle ? olStrokeStyle.getWidth() : undefined,
            rotate: (rotation !== undefined) ? rotation / Math.PI * 180 : undefined
        };
    };
    /**
     * Get the GeoStyler-Style Symbolizer from an OpenLayers Style object.
     *
     * @param olStyle The OpenLayers Style object
     * @return The GeoStyler-Style Symbolizer array
     */
    OlStyleParser.prototype.getSymbolizersFromOlStyle = function (olStyles) {
        var _this = this;
        var symbolizers = [];
        olStyles.forEach(function (olStyle) {
            var symbolizer;
            var styleType = _this.getStyleTypeFromOlStyle(olStyle);
            switch (styleType) {
                case 'Point':
                    if (olStyle.getText() && !OlStyleUtil_1.default.getIsMarkSymbolizerFont(olStyle.getText().getFont())) {
                        symbolizer = _this.getTextSymbolizerFromOlStyle(olStyle);
                    }
                    else {
                        symbolizer = _this.getPointSymbolizerFromOlStyle(olStyle);
                    }
                    break;
                case 'Line':
                    symbolizer = _this.getLineSymbolizerFromOlStyle(olStyle);
                    break;
                case 'Fill':
                    symbolizer = _this.getFillSymbolizerFromOlStyle(olStyle);
                    break;
                default:
                    throw new Error('Failed to parse SymbolizerKind from OpenLayers Style');
            }
            symbolizers.push(symbolizer);
        });
        return symbolizers;
    };
    /**
     * Get the GeoStyler-Style Rule from an OpenLayers Style object.
     *
     * @param {OlStyle} olStyle The OpenLayers Style object
     * @return {Rule} The GeoStyler-Style Rule
     */
    OlStyleParser.prototype.getRuleFromOlStyle = function (olStyles) {
        var symbolizers;
        var name = 'OL Style Rule 0';
        if (Array.isArray(olStyles)) {
            symbolizers = this.getSymbolizersFromOlStyle(olStyles);
        }
        else {
            symbolizers = this.getSymbolizersFromOlStyle([olStyles]);
        }
        return {
            name: name,
            symbolizers: symbolizers
        };
    };
    /**
     * Get the GeoStyler-Style Symbolizer from an OpenLayers Style object.
     *
     * @param {OlStyle} olStyle The OpenLayers Style object
     * @return {Symbolizer} The GeoStyler-Style Symbolizer
     */
    OlStyleParser.prototype.getStyleTypeFromOlStyle = function (olStyle) {
        var styleType;
        if (olStyle.getImage() instanceof this.OlStyleImageConstructor) {
            styleType = 'Point';
        }
        else if (olStyle.getText() instanceof this.OlStyleTextConstructor) {
            styleType = 'Point';
        }
        else if (olStyle.getFill() instanceof this.OlStyleFillConstructor) {
            styleType = 'Fill';
        }
        else if (olStyle.getStroke() && !olStyle.getFill()) {
            styleType = 'Line';
        }
        else {
            throw new Error('StyleType could not be detected');
        }
        return styleType;
    };
    /**
     * Get the GeoStyler-Style Style from an OpenLayers Style object.
     *
     * @param olStyle The OpenLayers Style object
     * @return The GeoStyler-Style Style
     */
    OlStyleParser.prototype.olStyleToGeoStylerStyle = function (olStyle) {
        var name = 'OL Style';
        var rule = this.getRuleFromOlStyle(olStyle);
        return {
            name: name,
            rules: [rule]
        };
    };
    /**
     * The readStyle implementation of the GeoStyler-Style StyleParser interface.
     * It reads an OpenLayers Style, an array of OpenLayers Styles or an olParserStyleFct and returns a Promise.
     *
     * The Promise itself resolves with a GeoStyler-Style Style.
     *
     * @param olStyle The style to be parsed
     * @return The Promise resolving with the GeoStyler-Style Style
     */
    OlStyleParser.prototype.readStyle = function (olStyle) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                if (_this.isOlParserStyleFct(olStyle)) {
                    resolve(olStyle.__geoStylerStyle);
                }
                else {
                    olStyle = olStyle;
                    var geoStylerStyle = _this.olStyleToGeoStylerStyle(olStyle);
                    resolve(geoStylerStyle);
                }
            }
            catch (error) {
                reject(error);
            }
        });
    };
    /**
     * The writeStyle implementation of the GeoStyler-Style StyleParser interface.
     * It reads a GeoStyler-Style Style and returns a Promise.
     * The Promise itself resolves one of three types
     *
     * 1. OlStyle if input Style consists of
     *    one rule with one symbolizer, no filter, no scaleDenominator, no TextSymbolizer
     * 2. OlStyle[] if input Style consists of
     *    one rule with multiple symbolizers, no filter, no scaleDenominator, no TextSymbolizer
     * 3. OlParserStyleFct for everything else
     *
     * @param {Style} geoStylerStyle A GeoStyler-Style Style.
     * @return {Promise} The Promise resolving with one of above mentioned style types.
     */
    OlStyleParser.prototype.writeStyle = function (geoStylerStyle) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                var olStyle = _this.getOlStyleTypeFromGeoStylerStyle(geoStylerStyle);
                resolve(olStyle);
            }
            catch (error) {
                reject(error);
            }
        });
    };
    /**
     * Decides which OlStyleType should be returned depending on given geoStylerStyle.
     * Three OlStyleTypes are possible:
     *
     * 1. OlStyle if input Style consists of
     *    one rule with one symbolizer, no filter, no scaleDenominator, no TextSymbolizer
     * 2. OlStyle[] if input Style consists of
     *    one rule with multiple symbolizers, no filter, no scaleDenominator, no TextSymbolizer
     * 3. OlParserStyleFct for everything else
     *
     * @param A GeoStyler-Style Style
     */
    OlStyleParser.prototype.getOlStyleTypeFromGeoStylerStyle = function (geoStylerStyle) {
        var rules = geoStylerStyle.rules;
        var nrRules = rules.length;
        if (nrRules === 1) {
            var hasFilter = typeof _get(geoStylerStyle, 'rules[0].filter') !== 'undefined' ? true : false;
            var hasMinScale = typeof _get(geoStylerStyle, 'rules[0].scaleDenominator.min') !== 'undefined' ? true : false;
            var hasMaxScale = typeof _get(geoStylerStyle, 'rules[0].scaleDenominator.max') !== 'undefined' ? true : false;
            var hasScaleDenominator = hasMinScale || hasMaxScale ? true : false;
            var nrSymbolizers = geoStylerStyle.rules[0].symbolizers.length;
            var hasTextSymbolizer = rules[0].symbolizers.some(function (symbolizer) {
                return symbolizer.kind === 'Text';
            });
            var hasDynamicIconSymbolizer = rules[0].symbolizers.some(function (symbolizer) {
                var _a;
                return symbolizer.kind === 'Icon' && ((_a = symbolizer.image) === null || _a === void 0 ? void 0 : _a.includes('{{'));
            });
            if (!hasFilter && !hasScaleDenominator && !hasTextSymbolizer && !hasDynamicIconSymbolizer) {
                if (nrSymbolizers === 1) {
                    return this.geoStylerStyleToOlStyle(geoStylerStyle);
                }
                else {
                    return this.geoStylerStyleToOlStyleArray(geoStylerStyle);
                }
            }
            else {
                return this.geoStylerStyleToOlParserStyleFct(geoStylerStyle);
            }
        }
        else {
            return this.geoStylerStyleToOlParserStyleFct(geoStylerStyle);
        }
    };
    /**
     * Parses the first symbolizer of the first rule of a GeoStyler-Style Style.
     *
     * @param {geoStylerStyle} A GeoStyler-Style Style
     * @return {OlStyle} An OpenLayers Style Object
     */
    OlStyleParser.prototype.geoStylerStyleToOlStyle = function (geoStylerStyle) {
        var rule = geoStylerStyle.rules[0];
        var symbolizer = rule.symbolizers[0];
        var olSymbolizer = this.getOlSymbolizerFromSymbolizer(symbolizer);
        return olSymbolizer;
    };
    /**
     * Parses all symbolizers of the first rule of a GeoStyler-Style Style.
     *
     * @param {geoStylerStyle} A GeoStyler-Style Style
     * @return {OlStyle[]} An array of OpenLayers Style Objects
     */
    OlStyleParser.prototype.geoStylerStyleToOlStyleArray = function (geoStylerStyle) {
        var _this = this;
        var rule = geoStylerStyle.rules[0];
        var olStyles = [];
        rule.symbolizers.forEach(function (symbolizer) {
            var olSymbolizer = _this.getOlSymbolizerFromSymbolizer(symbolizer);
            olStyles.push(olSymbolizer);
        });
        return olStyles;
    };
    /**
     * Get the OpenLayers Style object from an GeoStyler-Style Style
     *
     * @param {Style} geoStylerStyle A GeoStyler-Style Style.
     * @return {OlParserStyleFct} An OlParserStyleFct
     */
    OlStyleParser.prototype.geoStylerStyleToOlParserStyleFct = function (geoStylerStyle) {
        var _this = this;
        var rules = geoStylerStyle.rules;
        var olStyle = function (feature, resolution) {
            var styles = [];
            var scale = MapUtil_1.default.getScaleForResolution(resolution, 'm');
            rules.forEach(function (rule) {
                // handling scale denominator
                var minScale = _get(rule, 'scaleDenominator.min');
                var maxScale = _get(rule, 'scaleDenominator.max');
                var isWithinScale = true;
                if (typeof minScale !== 'undefined' || typeof maxScale !== 'undefined') {
                    if (typeof minScale !== 'undefined' && scale < minScale) {
                        isWithinScale = false;
                    }
                    if (typeof maxScale !== 'undefined' && scale >= maxScale) {
                        isWithinScale = false;
                    }
                }
                // handling filter
                var matchesFilter = false;
                if (!rule.filter) {
                    matchesFilter = true;
                }
                else {
                    try {
                        matchesFilter = _this.geoStylerFilterToOlParserFilter(feature, rule.filter);
                    }
                    catch (e) {
                        matchesFilter = false;
                    }
                }
                if (isWithinScale && matchesFilter) {
                    rule.symbolizers.forEach(function (symb) {
                        var olSymbolizer = _this.getOlSymbolizerFromSymbolizer(symb);
                        // this.getOlTextSymbolizerFromTextSymbolizer returns
                        // either an OlStyle or an ol.StyleFunction. OpenLayers only accepts an array
                        // of OlStyles, not ol.StyleFunctions.
                        // So we have to check it and in case of an ol.StyleFunction call that function
                        // and add the returned style to const styles.
                        if (typeof olSymbolizer !== 'function') {
                            styles.push(olSymbolizer);
                        }
                        else {
                            var styleFromFct = olSymbolizer(feature, resolution);
                            styles.push(styleFromFct);
                        }
                    });
                }
            });
            return styles;
        };
        var olStyleFct = olStyle;
        olStyleFct.__geoStylerStyle = geoStylerStyle;
        return olStyleFct;
    };
    /**
     * Checks if a feature matches given filter expression(s)
     * @param feature ol.Feature
     * @param filter Filter
     * @return boolean true if feature matches filter expression
     */
    OlStyleParser.prototype.geoStylerFilterToOlParserFilter = function (feature, filter) {
        var _this = this;
        var operatorMapping = {
            '&&': true,
            '||': true,
            '!': true
        };
        var matchesFilter = true;
        var operator = filter[0];
        var isNestedFilter = false;
        if (operatorMapping[operator]) {
            isNestedFilter = true;
        }
        try {
            if (isNestedFilter) {
                switch (filter[0]) {
                    case '&&':
                        var intermediate_1 = true;
                        var restFilter = filter.slice(1);
                        restFilter.forEach(function (f) {
                            if (!_this.geoStylerFilterToOlParserFilter(feature, f)) {
                                intermediate_1 = false;
                            }
                        });
                        matchesFilter = intermediate_1;
                        break;
                    case '||':
                        intermediate_1 = false;
                        restFilter = filter.slice(1);
                        restFilter.forEach(function (f) {
                            if (_this.geoStylerFilterToOlParserFilter(feature, f)) {
                                intermediate_1 = true;
                            }
                        });
                        matchesFilter = intermediate_1;
                        break;
                    case '!':
                        matchesFilter = !this.geoStylerFilterToOlParserFilter(feature, filter[1]);
                        break;
                    default:
                        throw new Error('Cannot parse Filter. Unknown combination or negation operator.');
                }
            }
            else {
                var prop = feature.get(filter[1]);
                switch (filter[0]) {
                    case '==':
                        matchesFilter = ('' + prop) === ('' + filter[2]);
                        break;
                    case '*=':
                        // inspired by
                        // https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/String/includes#Polyfill
                        if (typeof filter[2] === 'string' && typeof prop === 'string') {
                            if (filter[2].length > prop.length) {
                                matchesFilter = false;
                            }
                            else {
                                matchesFilter = prop.indexOf(filter[2]) !== -1;
                            }
                        }
                        break;
                    case '!=':
                        matchesFilter = ('' + prop) !== ('' + filter[2]);
                        break;
                    case '<':
                        matchesFilter = parseFloat(prop) < Number(filter[2]);
                        break;
                    case '<=':
                        matchesFilter = parseFloat(prop) <= Number(filter[2]);
                        break;
                    case '>':
                        matchesFilter = parseFloat(prop) > Number(filter[2]);
                        break;
                    case '>=':
                        matchesFilter = parseFloat(prop) >= Number(filter[2]);
                        break;
                    default:
                        throw new Error('Cannot parse Filter. Unknown comparison operator.');
                }
            }
        }
        catch (e) {
            throw new Error('Cannot parse Filter. Invalid structure.');
        }
        return matchesFilter;
    };
    /**
     * Get the OpenLayers Style object or an OL StyleFunction from an
     * GeoStyler-Style Symbolizer.
     *
     * @param {Symbolizer} symbolizer A GeoStyler-Style Symbolizer.
     * @return {object} The OpenLayers Style object or a StyleFunction
     */
    OlStyleParser.prototype.getOlSymbolizerFromSymbolizer = function (symbolizer) {
        var olSymbolizer;
        switch (symbolizer.kind) {
            case 'Mark':
                olSymbolizer = this.getOlPointSymbolizerFromMarkSymbolizer(symbolizer);
                break;
            case 'Icon':
                olSymbolizer = this.getOlIconSymbolizerFromIconSymbolizer(symbolizer);
                break;
            case 'Text':
                olSymbolizer = this.getOlTextSymbolizerFromTextSymbolizer(symbolizer);
                break;
            case 'Line':
                olSymbolizer = this.getOlLineSymbolizerFromLineSymbolizer(symbolizer);
                break;
            case 'Fill':
                olSymbolizer = this.getOlPolygonSymbolizerFromFillSymbolizer(symbolizer);
                break;
            default:
                // Return the OL default style since the TS type binding does not allow
                // us to set olSymbolizer to undefined
                var fill = new this.OlStyleFillConstructor({
                    color: 'rgba(255,255,255,0.4)'
                });
                var stroke = new this.OlStyleStrokeConstructor({
                    color: '#3399CC',
                    width: 1.25
                });
                olSymbolizer = new this.OlStyleConstructor({
                    image: new this.OlStyleCircleConstructor({
                        fill: fill,
                        stroke: stroke,
                        radius: 5
                    }),
                    fill: fill,
                    stroke: stroke
                });
                break;
        }
        return olSymbolizer;
    };
    /**
     * Get the OL Style object  from an GeoStyler-Style MarkSymbolizer.
     *
     * @param {MarkSymbolizer} markSymbolizer A GeoStyler-Style MarkSymbolizer.
     * @return {object} The OL Style object
     */
    OlStyleParser.prototype.getOlPointSymbolizerFromMarkSymbolizer = function (markSymbolizer) {
        var stroke;
        if (markSymbolizer.strokeColor || markSymbolizer.strokeWidth !== undefined) {
            stroke = new this.OlStyleStrokeConstructor({
                color: (markSymbolizer.strokeColor && (markSymbolizer.strokeOpacity !== undefined)) ?
                    OlStyleUtil_1.default.getRgbaColor(markSymbolizer.strokeColor, markSymbolizer.strokeOpacity) :
                    markSymbolizer.strokeColor,
                width: markSymbolizer.strokeWidth,
            });
        }
        var fill = new this.OlStyleFillConstructor({
            color: (markSymbolizer.color && markSymbolizer.opacity !== undefined) ?
                OlStyleUtil_1.default.getRgbaColor(markSymbolizer.color, markSymbolizer.opacity) : markSymbolizer.color
        });
        var olStyle;
        var shapeOpts = {
            fill: fill,
            // @ts-ignore
            opacity: markSymbolizer.opacity || 1,
            radius: markSymbolizer.radius || 5,
            rotation: markSymbolizer.rotate ? markSymbolizer.rotate * Math.PI / 180 : undefined,
            stroke: stroke,
            displacement: markSymbolizer.offset
        };
        switch (markSymbolizer.wellKnownName) {
            case 'shape://dot':
            case 'circle':
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleCircleConstructor(shapeOpts)
                });
                break;
            case 'square':
                shapeOpts.points = 4;
                shapeOpts.angle = 45 * Math.PI / 180;
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(shapeOpts)
                });
                break;
            case 'triangle':
                shapeOpts.points = 3;
                shapeOpts.angle = 0;
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(shapeOpts)
                });
                break;
            case 'star':
                shapeOpts.points = 5;
                shapeOpts.radius2 = shapeOpts.radius / 2.5;
                shapeOpts.angle = 0;
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(shapeOpts)
                });
                break;
            case 'shape://plus':
            case 'cross':
                shapeOpts.points = 4;
                shapeOpts.radius2 = 0;
                shapeOpts.angle = 0;
                // openlayers does not seem to set a default stroke color,
                // which is needed for regularshapes with radius2 = 0
                if (shapeOpts.stroke === undefined) {
                    shapeOpts.stroke = new this.OlStyleStrokeConstructor({
                        color: '#000'
                    });
                }
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(shapeOpts)
                });
                break;
            case 'shape://times':
            case 'x':
                shapeOpts.points = 4;
                shapeOpts.radius2 = 0;
                shapeOpts.angle = 45 * Math.PI / 180;
                // openlayers does not seem to set a default stroke color,
                // which is needed for regularshapes with radius2 = 0
                if (shapeOpts.stroke === undefined) {
                    shapeOpts.stroke = new this.OlStyleStrokeConstructor({
                        color: '#000'
                    });
                }
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(shapeOpts)
                });
                break;
            case 'shape://backslash':
                shapeOpts.points = 2;
                shapeOpts.angle = 2 * Math.PI - (Math.PI / 4);
                // openlayers does not seem to set a default stroke color,
                // which is needed for regularshapes with radius2 = 0
                if (shapeOpts.stroke === undefined) {
                    shapeOpts.stroke = new this.OlStyleStrokeConstructor({
                        color: '#000'
                    });
                }
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(shapeOpts)
                });
                break;
            case 'shape://horline':
                shapeOpts.points = 2;
                shapeOpts.angle = Math.PI / 2;
                // openlayers does not seem to set a default stroke color,
                // which is needed for regularshapes with radius2 = 0
                if (shapeOpts.stroke === undefined) {
                    shapeOpts.stroke = new this.OlStyleStrokeConstructor({
                        color: '#000'
                    });
                }
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(shapeOpts)
                });
                break;
            // so far, both arrows are closed arrows. Also, shape is a regular triangle with
            // all sides of equal length. In geoserver arrows only have two sides of equal length.
            // TODO redefine shapes of arrows?
            case 'shape://oarrow':
            case 'shape://carrow':
                shapeOpts.points = 3;
                shapeOpts.angle = Math.PI / 2;
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(shapeOpts)
                });
                break;
            case 'shape://slash':
                shapeOpts.points = 2;
                shapeOpts.angle = Math.PI / 4;
                // openlayers does not seem to set a default stroke color,
                // which is needed for regularshapes with radius2 = 0
                if (shapeOpts.stroke === undefined) {
                    shapeOpts.stroke = new this.OlStyleStrokeConstructor({
                        color: '#000'
                    });
                }
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(shapeOpts)
                });
                break;
            case 'shape://vertline':
                shapeOpts.points = 2;
                shapeOpts.angle = 0;
                // openlayers does not seem to set a default stroke color,
                // which is needed for regularshapes with radius2 = 0
                if (shapeOpts.stroke === undefined) {
                    shapeOpts.stroke = new this.OlStyleStrokeConstructor({
                        color: '#000'
                    });
                }
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(shapeOpts)
                });
                break;
            default:
                if (OlStyleUtil_1.default.getIsFontGlyphBased(markSymbolizer)) {
                    olStyle = new this.OlStyleConstructor({
                        text: new this.OlStyleTextConstructor({
                            text: OlStyleUtil_1.default.getCharacterForMarkSymbolizer(markSymbolizer),
                            font: OlStyleUtil_1.default.getTextFontForMarkSymbolizer(markSymbolizer),
                            fill: shapeOpts.fill,
                            stroke: shapeOpts.stroke,
                            rotation: shapeOpts.rotation
                        })
                    });
                    break;
                }
                throw new Error('MarkSymbolizer cannot be parsed. Unsupported WellKnownName.');
        }
        return olStyle;
    };
    /**
     * Get the OL Style object  from an GeoStyler-Style IconSymbolizer.
     *
     * @param {IconSymbolizer} symbolizer  A GeoStyler-Style IconSymbolizer.
     * @return {object} The OL Style object
     */
    OlStyleParser.prototype.getOlIconSymbolizerFromIconSymbolizer = function (symbolizer) {
        var _this = this;
        var baseProps = {
            src: symbolizer.image,
            crossOrigin: 'anonymous',
            opacity: symbolizer.opacity,
            scale: symbolizer.size || 1,
            // Rotation in openlayers is radians while we use degree
            rotation: symbolizer.rotate ? symbolizer.rotate * Math.PI / 180 : undefined,
            displacement: symbolizer.offset
        };
        // check if IconSymbolizer.image contains a placeholder
        var prefix = '\\{\\{';
        var suffix = '\\}\\}';
        var regExp = new RegExp(prefix + '.*?' + suffix, 'g');
        var regExpRes = symbolizer.image ? symbolizer.image.match(regExp) : null;
        if (regExpRes) {
            // if it contains a placeholder
            // return olStyleFunction
            var olPointStyledIconFn = function (feature) {
                var src = OlStyleUtil_1.default.resolveAttributeTemplate(feature, symbolizer.image, '');
                // src can't be blank, would trigger ol errors
                if (!src) {
                    src = symbolizer.image + '';
                }
                var image;
                if (_this.olIconStyleCache[src]) {
                    image = _this.olIconStyleCache[src];
                    image.setScale(baseProps.scale);
                    if (baseProps.rotation !== undefined) {
                        image.setRotation(baseProps.rotation);
                    }
                    if (baseProps.opacity !== undefined) {
                        image.setOpacity(baseProps.opacity);
                    }
                }
                else {
                    image = new _this.OlStyleIconConstructor(__assign(__assign({}, baseProps), { src: src // order is important
                     }));
                    _this.olIconStyleCache[src] = image;
                }
                var style = new _this.OlStyleConstructor({
                    image: image
                });
                return style;
            };
            return olPointStyledIconFn;
        }
        else {
            return new this.OlStyleConstructor({
                image: new this.OlStyleIconConstructor(__assign({}, baseProps))
            });
        }
    };
    /**
     * Get the OL Style object from an GeoStyler-Style LineSymbolizer.
     *
     * @param {LineSymbolizer} lineSymbolizer A GeoStyler-Style LineSymbolizer.
     * @return {object} The OL Style object
     */
    OlStyleParser.prototype.getOlLineSymbolizerFromLineSymbolizer = function (symbolizer) {
        return new this.OlStyleConstructor({
            stroke: new this.OlStyleStrokeConstructor({
                color: (symbolizer.color && symbolizer.opacity !== null && symbolizer.opacity !== undefined) ?
                    OlStyleUtil_1.default.getRgbaColor(symbolizer.color, symbolizer.opacity) : symbolizer.color,
                width: symbolizer.width,
                lineCap: symbolizer.cap,
                lineJoin: symbolizer.join,
                lineDash: symbolizer.dasharray,
                lineDashOffset: symbolizer.dashOffset
            })
        });
    };
    /**
     * Get the OL Style object from an GeoStyler-Style FillSymbolizer.
     *
     * @param {FillSymbolizer} fillSymbolizer A GeoStyler-Style FillSymbolizer.
     * @return {object} The OL Style object
     */
    OlStyleParser.prototype.getOlPolygonSymbolizerFromFillSymbolizer = function (symbolizer) {
        var fill = symbolizer.color ? new this.OlStyleFillConstructor({
            color: (symbolizer.opacity !== null && symbolizer.opacity !== undefined) ?
                OlStyleUtil_1.default.getRgbaColor(symbolizer.color, symbolizer.opacity) : symbolizer.color
        }) : null;
        var stroke = symbolizer.outlineColor ? new this.OlStyleStrokeConstructor({
            color: (symbolizer.outlineOpacity !== null && symbolizer.outlineOpacity !== undefined) ?
                OlStyleUtil_1.default.getRgbaColor(symbolizer.outlineColor, symbolizer.outlineOpacity) : symbolizer.outlineColor,
            width: symbolizer.outlineWidth,
            lineDash: symbolizer.outlineDasharray,
        }) : null;
        var olStyle = new this.OlStyleConstructor({
            fill: fill,
            stroke: stroke
        });
        if (symbolizer.graphicFill) {
            var pattern = this.getOlPatternFromGraphicFill(symbolizer.graphicFill);
            if (!fill) {
                fill = new this.OlStyleFillConstructor({});
            }
            if (pattern) {
                fill.setColor(pattern);
            }
            olStyle.setFill(fill);
        }
        return olStyle;
    };
    /**
     * Get the pattern for a graphicFill.
     *
     * This creates a CanvasPattern based on the
     * properties of the given PointSymbolizer. Currently,
     * only IconSymbolizer and MarkSymbolizer are supported.
     *
     * @param {PointSymbolizer} graphicFill The Symbolizer that holds the pattern config.
     * @returns The created CanvasPattern, or null.
     */
    OlStyleParser.prototype.getOlPatternFromGraphicFill = function (graphicFill) {
        var graphicFillStyle;
        if ((0, geostyler_style_1.isIconSymbolizer)(graphicFill)) {
            graphicFillStyle = this.getOlIconSymbolizerFromIconSymbolizer(graphicFill);
            var graphicFillImage = graphicFillStyle === null || graphicFillStyle === void 0 ? void 0 : graphicFillStyle.getImage();
            graphicFillImage === null || graphicFillImage === void 0 ? void 0 : graphicFillImage.load(); // Needed for Icon type images with a remote src
            // We can only work with the image once it's loaded
            if ((graphicFillImage === null || graphicFillImage === void 0 ? void 0 : graphicFillImage.getImageState()) !== ImageState_1.default.LOADED) {
                return null;
            }
        }
        else if ((0, geostyler_style_1.isMarkSymbolizer)(graphicFill)) {
            graphicFillStyle = this.getOlPointSymbolizerFromMarkSymbolizer(graphicFill);
        }
        else {
            return null;
        }
        // We need to clone the style and image since we'll be changing the scale below (hack)
        var graphicFillStyleCloned = graphicFillStyle.clone();
        var imageCloned = graphicFillStyleCloned.getImage();
        // Temporary canvas.
        // TODO: Can/should we reuse an pre-existing one for efficiency?
        var tmpCanvas = document.createElement('canvas');
        var tmpContext = tmpCanvas.getContext('2d');
        // Hack to make scaling work for Icons.
        // TODO: find a better way than this.
        var scale = imageCloned.getScale() || 1;
        var pixelRatio = scale;
        imageCloned.setScale(1);
        var size = imageCloned.getSize();
        // Create the context where we'll be drawing the style on
        var vectorContext = (0, render_1.toContext)(tmpContext, {
            pixelRatio: pixelRatio,
            size: size
        });
        // Draw the graphic
        vectorContext.setStyle(graphicFillStyleCloned);
        var pointCoords = size.map(function (item) { return item / 2; });
        vectorContext.drawGeometry(new Point_1.default(pointCoords));
        // Create the actual pattern and return style
        return tmpContext.createPattern(tmpCanvas, 'repeat');
    };
    /**
     * Get the OL StyleFunction object from an GeoStyler-Style TextSymbolizer.
     *
     * @param {TextSymbolizer} textSymbolizer A GeoStyler-Style TextSymbolizer.
     * @return {object} The OL StyleFunction
     */
    OlStyleParser.prototype.getOlTextSymbolizerFromTextSymbolizer = function (symbolizer) {
        var _this = this;
        var baseProps = {
            font: OlStyleUtil_1.default.getTextFont(symbolizer),
            fill: new this.OlStyleFillConstructor({
                color: (symbolizer.color && symbolizer.opacity !== null && symbolizer.opacity !== undefined) ?
                    OlStyleUtil_1.default.getRgbaColor(symbolizer.color, symbolizer.opacity) : symbolizer.color
            }),
            stroke: new this.OlStyleStrokeConstructor({
                color: (symbolizer.haloColor && symbolizer.opacity !== null && symbolizer.opacity !== undefined) ?
                    OlStyleUtil_1.default.getRgbaColor(symbolizer.haloColor, symbolizer.opacity) : symbolizer.haloColor,
                width: symbolizer.haloWidth ? symbolizer.haloWidth : 0
            }),
            overflow: symbolizer.allowOverlap,
            offsetX: symbolizer.offset ? symbolizer.offset[0] : 0,
            offsetY: symbolizer.offset ? symbolizer.offset[1] : 0,
            rotation: symbolizer.rotate ? symbolizer.rotate * Math.PI / 180 : undefined
            // TODO check why props match
            // textAlign: symbolizer.pitchAlignment,
            // textBaseline: symbolizer.anchor
        };
        // check if TextSymbolizer.label contains a placeholder
        var prefix = '\\{\\{';
        var suffix = '\\}\\}';
        var regExp = new RegExp(prefix + '.*?' + suffix, 'g');
        var regExpRes = symbolizer.label ? symbolizer.label.match(regExp) : null;
        if (regExpRes) {
            // if it contains a placeholder
            // return olStyleFunction
            var olPointStyledLabelFn = function (feature) {
                var text = new _this.OlStyleTextConstructor(__assign({ text: OlStyleUtil_1.default.resolveAttributeTemplate(feature, symbolizer.label, '') }, baseProps));
                var style = new _this.OlStyleConstructor({
                    text: text
                });
                return style;
            };
            return olPointStyledLabelFn;
        }
        else {
            // if TextSymbolizer does not contain a placeholder
            // return OlStyle
            return new this.OlStyleConstructor({
                text: new this.OlStyleTextConstructor(__assign({ text: symbolizer.label }, baseProps))
            });
        }
    };
    /**
     * The name of the OlStyleParser.
     */
    OlStyleParser.title = 'OpenLayers Style Parser';
    return OlStyleParser;
}());
exports.OlStyleParser = OlStyleParser;
exports.default = OlStyleParser;
//# sourceMappingURL=OlStyleParser.js.map